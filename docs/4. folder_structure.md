# Folder Structure

> Legacy reference only. Superseded by `02-system-architecture.md`, `03-canonical-contracts.md`, and `06-local-dev-and-deploy.md`.

Below is a ready-to-run blueprint you can implement almost 1:1: monorepo layout, service responsibilities, REST endpoints, WebSocket message types, and the exact event stream contracts.

I'm going to assume TypeScript everywhere (Next.js + Node), Postgres + Redis, and pgvector.

---

## Monorepo folder structure

```
rpg-ai/
  apps/
    web/                        # Next.js UI
      src/
        app/
        components/
        lib/
        styles/
      package.json
      next.config.js

    api/                        # REST API (Fastify/Nest)
      src/
        modules/
          auth/
          campaigns/
          characters/
          uploads/
          rag/
        lib/
        main.ts
      package.json

    realtime/                   # WebSocket Game Server (authoritative)
      src/
        rooms/
        engine/
        validators/
        events/
        main.ts
      package.json

    llm-orchestrator/           # Prompt builder + tool parsing + calls to realtime
      src/
        prompts/
        tools/
        orchestrate.ts
        main.ts
      package.json

    worker/                     # Background jobs: embeddings, images, summarization
      src/
        jobs/
          ingest_pdf.ts
          embed_chunks.ts
          generate_image.ts
          summarize_session.ts
        main.ts
      package.json

  packages/
    shared/                     # Shared types + schemas + utils
      src/
        types/
          ws.ts
          events.ts
          domain.ts
        schemas/
          zod.ts
        rules/
          edition.ts
          srd5e.ts              # v1: SRD only
      package.json

    db/
      migrations/
      sql/
      package.json

  infra/
    docker/
      docker-compose.yml
      postgres-init.sql
    k8s/                        # later
  .env.example
  package.json
  pnpm-workspace.yaml
  README.md
```

**Recommended "run locally" (docker-compose)**

- Postgres (with pgvector)
- Redis
- (optional) MinIO/S3-compatible storage for uploads

---

## Services and who owns what

### apps/realtime (Authoritative Game Server)

**Owns:**

- encounter legality (turn order, action economy)
- dice roll generation (server-signed)
- applying patches to state + writing event stream
- broadcasting events to all players

### apps/llm-orchestrator

**Owns:**

- building prompt input (snapshot + events + summaries + RAG chunks)
- calling model
- parsing tool calls
- sending tool requests back to realtime for validation/execution

### apps/api

**Owns:**

- user auth
- CRUD campaigns/characters
- PDF upload endpoints
- RAG search endpoints (can proxy to worker/db)
- issuing WS tokens

### apps/worker

**Owns:**

- PDF ingestion: extract text → chunk → embed → store in rag_chunk
- summarization jobs (periodic)
- image generation jobs

---

## REST API endpoints (v1)

**Auth**

- `POST /auth/register`
- `POST /auth/login`
- `POST /auth/refresh`

**Campaigns**

- `POST /campaigns`
- `GET /campaigns`
- `GET /campaigns/:id`
- `POST /campaigns/:id/join` (returns WS token + role)
- `GET /campaigns/:id/players`

**Characters**

- `POST /campaigns/:id/characters`
- `GET /campaigns/:id/characters`
- `PATCH /characters/:id` (out of encounter edits; in encounter only via realtime patches)

**Uploads + RAG**

- `POST /campaigns/:id/uploads/pdf` (multipart)
- `POST /campaigns/:id/rag/ingest` (kicks worker job, returns job_id)
- `POST /rag/search` (query + filters)
- `GET /rag/docs?campaign_id=...`

**Session**

- `GET /campaigns/:id/snapshot`
- `GET /campaigns/:id/events?after_seq=...&limit=...`

---

## WebSocket protocol (the important part)

**WS URL**

- `wss://.../ws?token=<ws_token>`

**Rules**

- Client messages are commands
- Server messages are events (authoritative)
- Everything that matters becomes a `game_event` with `(campaign_id, seq)`

---

## Shared WS types (`packages/shared/src/types/ws.ts`)

```ts
export type UUID = string;

export type ClientMsg =
  | ClientHello
  | ClientJoinCampaign
  | ClientPlayerAction
  | ClientAck
  | ClientPing;

export type ServerMsg =
  | ServerHello
  | ServerJoined
  | ServerEventBatch
  | ServerError
  | ServerPong;

export type ClientHello = {
  t: "client.hello";
  client_version: string;
  device_id?: string;
};

export type ClientJoinCampaign = {
  t: "client.join";
  campaign_id: UUID;
  last_seq_seen?: number; // for resume
};

export type ClientPlayerAction = {
  t: "client.player_action";
  campaign_id: UUID;
  client_msg_id: UUID; // idempotency key
  text: string; // free-form player input
  ui_hints?: {
    mode?: "free" | "combat";
    selected_actor_ref?: string; // "character:<uuid>"
  };
};

export type ClientAck = {
  t: "client.ack";
  campaign_id: UUID;
  upto_seq: number; // last seq applied by client
};

export type ClientPing = { t: "client.ping"; ts: number };

export type ServerHello = {
  t: "server.hello";
  server_time: number;
  connection_id: UUID;
};

export type ServerJoined = {
  t: "server.joined";
  campaign_id: UUID;
  role: "player" | "gm";
  snapshot: any; // state json
  last_seq: number;
};

export type ServerEventBatch = {
  t: "server.events";
  campaign_id: UUID;
  from_seq: number;
  to_seq: number;
  events: GameEvent[];
};

export type ServerError = {
  t: "server.error";
  campaign_id?: UUID;
  code: string;
  message: string;
  details?: any;
};

export type ServerPong = { t: "server.pong"; ts: number };

// Import from events.ts
import type { GameEvent } from "./events";
```

---

## Event stream contract (`packages/shared/src/types/events.ts`)

These are the canonical events written into `game_event` and broadcast.

```ts
export type UUID = string;

export type GameEvent =
  | EvPlayerAction
  | EvDmNarration
  | EvRollRequested
  | EvRollResult
  | EvStatePatchRequested
  | EvStatePatchApplied
  | EvEntityCreated
  | EvEncounterStarted
  | EvTurnAdvanced
  | EvAudioCue
  | EvErrorNote;

export type BaseEvent<T extends string, P> = {
  seq: number;
  campaign_id: UUID;
  type: T;
  ts: number; // epoch ms
  payload: P;
};

export type EvPlayerAction = BaseEvent<
  "player_action",
  {
    user_id: UUID;
    character_id?: UUID;
    client_msg_id: UUID;
    text: string;
  }
>;

export type EvDmNarration = BaseEvent<
  "dm_narration",
  {
    text: string; // DM story output shown to players
    options?: string[]; // 3–6 suggested actions
    npc_refs?: string[]; // e.g. ["npc:<uuid>"]
    location_ref?: string; // "location:<uuid>"
  }
>;

export type EvRollRequested = BaseEvent<
  "roll_requested",
  {
    request_id: UUID;
    formula: string; // "1d20+5"
    reason: string;
    actor_ref?: string; // "character:<uuid>" | "npc:<uuid>"
  }
>;

export type EvRollResult = BaseEvent<
  "roll_result",
  {
    request_id: UUID;
    formula: string;
    rolls: number[]; // e.g. [17]
    total: number; // e.g. 22
    signed: string; // server signature or hash
  }
>;

export type PatchOp = "set" | "inc" | "push" | "remove";

export type StatePatch = {
  op: PatchOp;
  target: "snapshot" | `character:${UUID}` | `npc:${UUID}` | `location:${UUID}`;
  path: string; // "/resources/hp_current"
  value?: any;
};

export type EvStatePatchRequested = BaseEvent<
  "state_patch_requested",
  {
    request_id: UUID;
    reason: string;
    patches: StatePatch[];
  }
>;

export type EvStatePatchApplied = BaseEvent<
  "state_patch_applied",
  {
    request_id: UUID;
    applied: StatePatch[];
    rejected?: { patch: StatePatch; why: string }[];
  }
>;

export type EvEntityCreated = BaseEvent<
  "entity_created",
  {
    entity_ref: `npc:${UUID}` | `location:${UUID}`;
    name: string;
    data: any;
  }
>;

export type EvEncounterStarted = BaseEvent<
  "encounter_started",
  {
    encounter_id: UUID;
    participants: string[]; // ["character:<uuid>", "npc:<uuid>"]
    initiative?: { ref: string; value: number }[];
  }
>;

export type EvTurnAdvanced = BaseEvent<
  "turn_advanced",
  {
    encounter_id: UUID;
    active_ref: string; // whose turn now
    round: number;
  }
>;

export type EvAudioCue = BaseEvent<
  "audio_cue",
  {
    cue: string; // "sword_hit"
    intensity: "low" | "mid" | "high";
    duration_ms?: number;
  }
>;

export type EvErrorNote = BaseEvent<
  "error_note",
  {
    message: string; // non-fatal note displayed in UI
    context?: any;
  }
>;
```

---

## Snapshot shape (`game_snapshot.state`) – minimal but sufficient

Keep it compact; everything else can be loaded by ID.

```ts
export type GameSnapshot = {
  campaign_id: string;
  edition: "5e";
  location_ref?: `location:${string}`;
  mode: "free" | "combat";
  encounter?: {
    encounter_id: string;
    round: number;
    active_ref: string; // "character:<id>" | "npc:<id>"
    initiative_order: string[];
  };
  scene: {
    title: string;
    short_summary: string;
    present_npcs: string[]; // ["npc:<id>"]
    present_characters: string[]; // ["character:<id>"]
  };
  rules_flags: {
    strict: true;
  };
};
```

---

## Realtime server processing pipeline (exact flow)

1. **Client sends action** → `client.player_action`
2. **Realtime validates basic constraints** — user is in campaign; if combat: is it their turn?; rate limiting; idempotency (client_msg_id)
3. **Realtime writes event:** `player_action` — increments seq, broadcasts
4. **Realtime triggers LLM Orchestrator** (async request) — Payload: campaign_id, last_seq, snapshot, last N events, character/npc/location minimal context refs (or orchestrator fetches via API/DB)
5. **Orchestrator does:** rag_search (rules + lore), model call, parses tool calls into: roll requests, state patch requests, entity create requests, audio cues, dm narration text + options
6. **Orchestrator sends tool requests back to realtime** (HTTP or internal RPC)
7. **Realtime executes in order:** generate roll(s) → writes roll_requested, roll_result; validate & apply patches → writes state_patch_requested, state_patch_applied; create entities → writes entity_created; audio cue → writes audio_cue; write dm_narration last
8. **Realtime updates snapshot** — updates game_snapshot.last_seq, game_snapshot.state, commits

---

## Orchestrator ↔ Realtime "tool RPC" contracts

These are not WS; use internal HTTP (simpler) or a queue.

**POST /internal/tools/execute**

Body:

```json
{
  "campaign_id": "uuid",
  "tool_calls": [
    { "name": "roll", "args": { "formula": "1d20+5", "reason": "Perception", "actor_ref": "character:..." } },
    { "name": "apply_state_patch", "args": { "reason": "Damage from hit", "patches": [ ... ] } },
    { "name": "create_entity", "args": { "entity_type": "npc", "name": "Mara", "data": { ... } } },
    { "name": "trigger_audio", "args": { "cue": "sword_hit", "intensity": "mid" } }
  ],
  "dm_narration": {
    "text": "…",
    "options": ["…", "…"]
  }
}
```

Realtime response:

```json
{
  "ok": true,
  "applied_seq_to": 1234
}
```

---

## Minimal "edition rules" approach for v1 (so it's implementable)

Do not build a full 5e rules engine in v1. Build a strict core:

**Core legality checks**

- In combat: must be active player
- One action per turn (track turn_state.action_used)
- Bonus action optional (track turn_state.bonus_used)
- Movement allowance (optional v1)
- Resources (spell slots, HP) only change via server patches

**Dice & checks**

- ability_check, skill_check, saving_throw, attack_roll, damage_roll
- Keep modifiers on character sheet; server calculates formula: d20 + proficiency? + stat mod + situational

**Where LLM helps**

- Determines what check is appropriate, but server computes formula.

So your orchestration becomes:

1. LLM: "This is a Perception check"
2. Server: "Perception = d20 + WIS mod + prof if proficient"

That single decision massively reduces hallucinated math.

---

## UI event handling (client-side)

**Client state**

- Keep last_seq_seen
- Apply events in order
- If a gap is detected → request resync via re-join with last_seq_seen

**Rendering rules**

- `dm_narration.text` → story feed
- `dm_narration.options` → quick action buttons
- `roll_result` → show "Rolled 17+5 = 22"
- `state_patch_applied` → update local cached sheet/snapshot
- `audio_cue` → play SFX

---

## "Ready-to-implement" message examples

**Player says: "I kick the door open"**

Client → server:

```json
{
  "t": "client.player_action",
  "campaign_id": "c1",
  "client_msg_id": "m1",
  "text": "I kick the door open"
}
```

**Server broadcasts:**

- player_action(seq=10)
- (LLM decides: STR check)
- roll_requested(seq=11, formula=1d20+3)
- roll_result(seq=12, total=19)
- state_patch_applied(seq=13, set door open flag in snapshot)
- dm_narration(seq=14, text=..., options=[...])
