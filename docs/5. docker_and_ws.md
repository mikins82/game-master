# Docker and WebSocket Server

> Legacy reference only. Superseded by `06-local-dev-and-deploy.md`, `03-canonical-contracts.md`, and `07-implementation-roadmap.md`.

Cool — here are the copy-pasteable starting files (Docker + realtime WS server + event store + Next.js client reducer). This is a solid spine you can build on.

---

## 1) infra/docker/docker-compose.yml

```yaml
version: "3.9"

services:
  postgres:
    image: pgvector/pgvector:pg16
    container_name: rpgai-postgres
    environment:
      POSTGRES_USER: rpgai
      POSTGRES_PASSWORD: rpgai
      POSTGRES_DB: rpgai
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./postgres-init.sql:/docker-entrypoint-initdb.d/00-init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U rpgai -d rpgai"]
      interval: 5s
      timeout: 3s
      retries: 20

  redis:
    image: redis:7-alpine
    container_name: rpgai-redis
    ports:
      - "6379:6379"
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redisdata:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 20

volumes:
  pgdata:
  redisdata:
```

### infra/docker/postgres-init.sql

```sql
create extension if not exists "uuid-ossp";
create extension if not exists vector;
```

**Run:**

```bash
docker compose -f infra/docker/docker-compose.yml up -d
```

---

## 2) Realtime WS server skeleton

### apps/realtime/package.json

```json
{
  "name": "@rpg-ai/realtime",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/main.ts",
    "start": "node dist/main.js",
    "build": "tsc -p tsconfig.json"
  },
  "dependencies": {
    "fastify": "^4.27.0",
    "ws": "^8.17.0",
    "zod": "^3.24.1",
    "pg": "^8.12.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "tsx": "^4.19.2",
    "typescript": "^5.7.3",
    "@types/ws": "^8.5.12",
    "@types/node": "^20.17.12"
  }
}
```

### apps/realtime/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}
```

### apps/realtime/src/env.ts

```ts
import { z } from "zod";

const Env = z.object({
  PORT: z.coerce.number().default(8082),
  DATABASE_URL: z
    .string()
    .default("postgres://rpgai:rpgai@localhost:5432/rpgai"),
});

export const env = Env.parse(process.env);
```

### apps/realtime/src/db.ts

```ts
import pg from "pg";
import { env } from "./env";

export const pool = new pg.Pool({
  connectionString: env.DATABASE_URL,
  max: 10,
});
```

### apps/realtime/src/types.ts

```ts
export type UUID = string;

export type GameEvent = {
  seq: number;
  campaign_id: UUID;
  type: string;
  ts: number; // epoch ms
  payload: unknown;
};

export type GameSnapshot = {
  campaign_id: UUID;
  last_seq: number;
  state: any; // keep flexible v1
};
```

---

## 3) Event store + snapshot update + broadcast

### apps/realtime/src/eventStore.ts

```ts
import { pool } from "./db";
import type { GameEvent, UUID } from "./types";

export async function ensureCampaignStream(campaignId: UUID) {
  // Create snapshot row if missing
  await pool.query(
    `insert into game_snapshot (campaign_id, last_seq, state)
     values ($1, 0, $2)
     on conflict (campaign_id) do nothing`,
    [campaignId, JSON.stringify(makeInitialSnapshotState(campaignId))],
  );
}

function makeInitialSnapshotState(campaignId: UUID) {
  return {
    campaign_id: campaignId,
    edition: "5e",
    mode: "free",
    scene: {
      title: "A quiet beginning",
      short_summary: "The party gathers, unaware of what's coming.",
      present_npcs: [],
      present_characters: [],
    },
    rules_flags: { strict: true },
  };
}

export async function readSnapshot(
  campaignId: UUID,
): Promise<{ last_seq: number; state: any }> {
  const res = await pool.query(
    `select last_seq, state from game_snapshot where campaign_id = $1`,
    [campaignId],
  );
  if (res.rowCount === 0) throw new Error("Snapshot not found");
  return { last_seq: res.rows[0].last_seq, state: res.rows[0].state };
}

export async function readEventsAfter(
  campaignId: UUID,
  afterSeq: number,
  limit = 200,
): Promise<GameEvent[]> {
  const res = await pool.query(
    `select seq, campaign_id, type, extract(epoch from created_at)*1000 as ts, payload
     from game_event
     where campaign_id = $1 and seq > $2
     order by seq asc
     limit $3`,
    [campaignId, afterSeq, limit],
  );

  return res.rows.map((r) => ({
    seq: Number(r.seq),
    campaign_id: r.campaign_id,
    type: r.type,
    ts: Number(r.ts),
    payload: r.payload,
  }));
}

export async function appendEvent(
  campaignId: UUID,
  type: string,
  payload: unknown,
  applyToSnapshot?: (state: any) => any,
): Promise<GameEvent> {
  // Single transaction: lock snapshot row, increment seq, insert event, update snapshot.
  return await pool.connect().then(async (client) => {
    try {
      await client.query("begin");

      const snapRes = await client.query(
        `select last_seq, state
         from game_snapshot
         where campaign_id = $1
         for update`,
        [campaignId],
      );
      if (snapRes.rowCount === 0)
        throw new Error("Snapshot missing (ensureCampaignStream first)");

      const lastSeq = Number(snapRes.rows[0].last_seq);
      const nextSeq = lastSeq + 1;

      const ts = Date.now();
      const eventRes = await client.query(
        `insert into game_event (campaign_id, seq, type, payload)
         values ($1, $2, $3, $4)
         returning campaign_id, seq, type, extract(epoch from created_at)*1000 as ts, payload`,
        [campaignId, nextSeq, type, JSON.stringify(payload)],
      );

      let newState = snapRes.rows[0].state;
      if (applyToSnapshot) newState = applyToSnapshot(newState);

      await client.query(
        `update game_snapshot set last_seq = $2, state = $3, updated_at = now()
         where campaign_id = $1`,
        [campaignId, nextSeq, JSON.stringify(newState)],
      );

      await client.query("commit");

      const row = eventRes.rows[0];
      return {
        campaign_id: row.campaign_id,
        seq: Number(row.seq),
        type: row.type,
        ts: Number(row.ts),
        payload: row.payload,
      };
    } catch (e) {
      await client.query("rollback");
      throw e;
    } finally {
      client.release();
    }
  });
}
```

---

## 4) WS server (join, resync, player_action → event stream)

### apps/realtime/src/wsProtocol.ts

```ts
import { z } from "zod";

export const ClientHello = z.object({
  t: z.literal("client.hello"),
  client_version: z.string(),
  device_id: z.string().optional(),
});

export const ClientJoin = z.object({
  t: z.literal("client.join"),
  campaign_id: z.string().uuid(),
  last_seq_seen: z.number().int().nonnegative().optional(),
});

export const ClientPlayerAction = z.object({
  t: z.literal("client.player_action"),
  campaign_id: z.string().uuid(),
  client_msg_id: z.string().uuid(),
  text: z.string().min(1).max(4000),
  ui_hints: z
    .object({
      mode: z.enum(["free", "combat"]).optional(),
      selected_actor_ref: z.string().optional(),
    })
    .optional(),
});

export const ClientAck = z.object({
  t: z.literal("client.ack"),
  campaign_id: z.string().uuid(),
  upto_seq: z.number().int().nonnegative(),
});

export const ClientPing = z.object({
  t: z.literal("client.ping"),
  ts: z.number().int(),
});

export const ClientMsg = z.union([
  ClientHello,
  ClientJoin,
  ClientPlayerAction,
  ClientAck,
  ClientPing,
]);

export type ClientMsg = z.infer<typeof ClientMsg>;
```

### apps/realtime/src/roomHub.ts

```ts
import type WebSocket from "ws";
import type { GameEvent } from "./types";

type Conn = {
  ws: WebSocket;
  campaignId?: string;
  userId?: string;
};

const rooms = new Map<string, Set<Conn>>();

export function joinRoom(conn: Conn, campaignId: string) {
  leaveRoom(conn);
  conn.campaignId = campaignId;
  if (!rooms.has(campaignId)) rooms.set(campaignId, new Set());
  rooms.get(campaignId)!.add(conn);
}

export function leaveRoom(conn: Conn) {
  if (!conn.campaignId) return;
  const set = rooms.get(conn.campaignId);
  if (set) {
    set.delete(conn);
    if (set.size === 0) rooms.delete(conn.campaignId);
  }
  conn.campaignId = undefined;
}

export function broadcastEvent(campaignId: string, event: GameEvent) {
  const set = rooms.get(campaignId);
  if (!set) return;
  const msg = JSON.stringify({
    t: "server.events",
    campaign_id: campaignId,
    from_seq: event.seq,
    to_seq: event.seq,
    events: [event],
  });
  for (const conn of set) {
    if (conn.ws.readyState === conn.ws.OPEN) conn.ws.send(msg);
  }
}

export function makeConn(ws: WebSocket, userId?: string): Conn {
  return { ws, userId };
}
```

### apps/realtime/src/main.ts

```ts
import Fastify from "fastify";
import WebSocket, { WebSocketServer } from "ws";
import { env } from "./env";
import { ClientMsg } from "./wsProtocol";
import {
  appendEvent,
  ensureCampaignStream,
  readEventsAfter,
  readSnapshot,
} from "./eventStore";
import { broadcastEvent, joinRoom, leaveRoom, makeConn } from "./roomHub";
import { randomUUID } from "node:crypto";

const app = Fastify({ logger: true });

// Minimal WS token validation placeholder.
// v1: accept any token and treat as user "anon". Replace with JWT later.
function getUserIdFromToken(token?: string) {
  if (!token) return "anon";
  return token.slice(0, 64);
}

app.get("/health", async () => ({ ok: true }));

const server = app.server;
const wss = new WebSocketServer({ server, path: "/ws" });

wss.on("connection", async (ws, req) => {
  const url = new URL(req.url ?? "", "http://localhost");
  const token = url.searchParams.get("token") ?? undefined;
  const userId = getUserIdFromToken(token);

  const conn = makeConn(ws, userId);

  ws.send(
    JSON.stringify({
      t: "server.hello",
      server_time: Date.now(),
      connection_id: randomUUID(),
    }),
  );

  ws.on("message", async (raw) => {
    try {
      const data = JSON.parse(raw.toString());
      const msg = ClientMsg.parse(data);

      if (msg.t === "client.hello") {
        return; // noop
      }

      if (msg.t === "client.ping") {
        ws.send(JSON.stringify({ t: "server.pong", ts: msg.ts }));
        return;
      }

      if (msg.t === "client.join") {
        await ensureCampaignStream(msg.campaign_id);
        joinRoom(conn, msg.campaign_id);

        const snap = await readSnapshot(msg.campaign_id);
        const lastSeen = msg.last_seq_seen ?? 0;

        // If client is behind, send snapshot + replay events
        const events =
          lastSeen < snap.last_seq
            ? await readEventsAfter(msg.campaign_id, lastSeen, 500)
            : [];

        ws.send(
          JSON.stringify({
            t: "server.joined",
            campaign_id: msg.campaign_id,
            role: "player",
            snapshot: snap.state,
            last_seq: snap.last_seq,
          }),
        );

        if (events.length) {
          ws.send(
            JSON.stringify({
              t: "server.events",
              campaign_id: msg.campaign_id,
              from_seq: events[0].seq,
              to_seq: events[events.length - 1].seq,
              events,
            }),
          );
        }
        return;
      }

      if (msg.t === "client.player_action") {
        if (!conn.campaignId || conn.campaignId !== msg.campaign_id) {
          ws.send(
            JSON.stringify({
              t: "server.error",
              code: "NOT_JOINED",
              message: "Join the campaign room before sending actions.",
            }),
          );
          return;
        }

        // 1) Append player_action event
        const ev = await appendEvent(
          msg.campaign_id,
          "player_action",
          {
            user_id: conn.userId,
            client_msg_id: msg.client_msg_id,
            text: msg.text,
          },
          (state) => state, // v1: snapshot unchanged here
        );
        broadcastEvent(msg.campaign_id, ev);

        // 2) v1 DM stub (replace with orchestrator call)
        // For now: immediate narrative response without tools.
        const dm = await appendEvent(
          msg.campaign_id,
          "dm_narration",
          {
            text:
              `You attempt: "${msg.text}".\n\n` +
              "The world reacts (stub DM). Next: we'll route this to the LLM orchestrator.",
            options: [
              "Look around",
              "Proceed cautiously",
              "Ask an NPC a question",
              "Do something else (type freely)",
            ],
          },
          (state) => {
            // keep a tiny rolling scene summary
            state.scene = state.scene ?? {};
            state.scene.short_summary = (state.scene.short_summary ?? "").slice(
              0,
              500,
            );
            return state;
          },
        );
        broadcastEvent(msg.campaign_id, dm);

        return;
      }

      if (msg.t === "client.ack") {
        // optional: store per-connection ack for QoS/metrics; v1 ignore
        return;
      }
    } catch (err: any) {
      ws.send(
        JSON.stringify({
          t: "server.error",
          code: "BAD_MESSAGE",
          message: err?.message ?? "Invalid message",
        }),
      );
    }
  });

  ws.on("close", () => {
    leaveRoom(conn);
  });
});

app.listen({ port: env.PORT, host: "0.0.0.0" }).catch((err) => {
  app.log.error(err);
  process.exit(1);
});
```

---

## 5) DB migrations for game_event + game_snapshot

Put this in `packages/db/sql/001_core.sql` and run it once (psql).

```sql
create table if not exists game_event (
  id uuid primary key default uuid_generate_v4(),
  campaign_id uuid not null,
  seq bigint not null,
  type text not null,
  payload jsonb not null,
  created_at timestamptz not null default now(),
  unique (campaign_id, seq)
);

create index if not exists idx_game_event_campaign_seq on game_event(campaign_id, seq);

create table if not exists game_snapshot (
  campaign_id uuid primary key,
  last_seq bigint not null,
  state jsonb not null,
  updated_at timestamptz not null default now()
);
```

---

## 6) Next.js client: event reducer + WS hook

### apps/web/src/lib/wsTypes.ts

```ts
export type UUID = string;

export type GameEvent = {
  seq: number;
  campaign_id: UUID;
  type: string;
  ts: number;
  payload: any;
};

export type ServerMsg =
  | { t: "server.hello"; server_time: number; connection_id: UUID }
  | {
      t: "server.joined";
      campaign_id: UUID;
      role: "player" | "gm";
      snapshot: any;
      last_seq: number;
    }
  | {
      t: "server.events";
      campaign_id: UUID;
      from_seq: number;
      to_seq: number;
      events: GameEvent[];
    }
  | { t: "server.error"; code: string; message: string; details?: any }
  | { t: "server.pong"; ts: number };
```

### apps/web/src/lib/reducer.ts

```ts
import type { GameEvent } from "./wsTypes";

export type ClientState = {
  connected: boolean;
  campaignId?: string;
  snapshot?: any;
  lastSeq: number;
  feed: { seq: number; kind: string; text: string; meta?: any }[];
  pendingGap?: { expected: number; got: number };
  errors: string[];
};

export const initialState: ClientState = {
  connected: false,
  lastSeq: 0,
  feed: [],
  errors: [],
};

function appendFeed(
  state: ClientState,
  item: ClientState["feed"][number],
): ClientState {
  const feed = [...state.feed, item].slice(-300);
  return { ...state, feed };
}

export function applyEvent(state: ClientState, ev: GameEvent): ClientState {
  // Gap detection
  const expected = state.lastSeq + 1;
  if (ev.seq !== expected) {
    return { ...state, pendingGap: { expected, got: ev.seq } };
  }

  let next: ClientState = { ...state, lastSeq: ev.seq, pendingGap: undefined };

  switch (ev.type) {
    case "player_action":
      return appendFeed(next, {
        seq: ev.seq,
        kind: "player",
        text: ev.payload?.text ?? "",
        meta: ev.payload,
      });

    case "dm_narration":
      next = appendFeed(next, {
        seq: ev.seq,
        kind: "dm",
        text: ev.payload?.text ?? "",
        meta: { options: ev.payload?.options ?? [] },
      });
      return next;

    case "roll_result":
      return appendFeed(next, {
        seq: ev.seq,
        kind: "system",
        text: `Roll: ${ev.payload?.formula} = ${ev.payload?.total}`,
        meta: ev.payload,
      });

    case "state_patch_applied":
      // Optional: if you also send a snapshot diff, apply it here.
      return appendFeed(next, {
        seq: ev.seq,
        kind: "system",
        text: "State updated.",
        meta: ev.payload,
      });

    case "audio_cue":
      // UI can play sound based on this, not handled in reducer by default.
      return next;

    default:
      return appendFeed(next, {
        seq: ev.seq,
        kind: "system",
        text: `[${ev.type}]`,
        meta: ev.payload,
      });
  }
}

export function applyEvents(
  state: ClientState,
  events: GameEvent[],
): ClientState {
  let s = state;
  for (const ev of events) {
    s = applyEvent(s, ev);
    if (s.pendingGap) break;
  }
  return s;
}
```

### apps/web/src/lib/useCampaignWs.ts

```ts
"use client";

import { useEffect, useMemo, useReducer, useRef } from "react";
import type { ServerMsg } from "./wsTypes";
import { applyEvents, initialState, type ClientState } from "./reducer";

type ClientMsg =
  | { t: "client.hello"; client_version: string }
  | { t: "client.join"; campaign_id: string; last_seq_seen?: number }
  | { t: "client.player_action"; campaign_id: string; client_msg_id: string; text: string }
  | { t: "client.ping"; ts: number };

function uuid(): string {
  // Browser-safe UUID
  return globalThis.crypto?.randomUUID ? globalThis.crypto.randomUUID() : `${Date.now()}-${Math.random()}`;
}

export function useCampaignWs(opts: { baseUrl: string; token: string; campaignId: string }) {
  const [state, setState] = useReducer(
    (s: ClientState, patch: Partial<ClientState>) => ({ ...s, ...patch }),
    initialState
  );

  const wsRef = useRef<WebSocket | null>(null);

  const wsUrl = useMemo(() => {
    const u = new URL(opts.baseUrl);
    u.protocol = u.protocol === "https:" ? "wss:" : "ws:";
    u.pathname = "/ws";
    u.searchParams.set("token", opts.token);
    return u.toString();
  }, [opts.baseUrl, opts.token]);

  useEffect(() => {
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      setState({ connected: true });
      const hello: ClientMsg = { t: "client.hello", client_version: "web-0.1" };
      ws.send(JSON.stringify(hello));

      const join: ClientMsg = { t: "client.join", campaign_id: opts.campaignId, last_seq_seen: 0 };
      ws.send(JSON.stringify(join));
    };

    ws.onmessage = (evt) => {
      const msg = JSON.parse(evt.data) as ServerMsg;

      if (msg.t === "server.joined") {
        setState({
          campaignId: msg.campaign_id,
          snapshot: msg.snapshot,
          lastSeq: msg.last_seq,
        });
        return;
      }

      if (msg.t === "server.events") {
        setState((prev) => {
          const next = applyEvents(prev as any, msg.events);
          // If gap detected, you can auto-resync by re-joining with lastSeq
          return next as any;
        } as any);
        return;
      }

      if (msg.t === "server.error") {
        setState((prev) => ({
          errors: [...prev.errors, `${msg.code}: ${msg.message}`].slice(-10),
        }) as any);
        return;
      }
    };

    ws.onclose = () => setState({ connected: false });
    ws.onerror = () => setState({ connected: false });

    const ping = setInterval(() => {
      if (ws.readyState === ws.OPEN) {
        const m: ClientMsg = { t: "client.ping", ts: Date.now() };
        ws.send(JSON.stringify(m));
      }
    }, 15000);

    return () => {
      clearInterval(ping);
      ws.close();
    };
  }, [wsUrl, opts.campaignId]);

  function sendAction(text: string) {
    const ws = wsRef.current;
    if (!ws || ws.readyState !== ws.OPEN) return;

    const msg: ClientMsg = {
      t: "client.player_action",
      campaign_id: opts.campaignId,
      client_msg_id: uuid(),
      text,
    };
    ws.send(JSON.stringify(msg));
  }

  return { state, sendAction };
}
```

> **Note:** Use `globalThis.crypto.randomUUID()` for browser-safe UUID; remove the `import { randomUUID } from "crypto"` line if your Next build complains.

---

## 7) Minimal UI page to test it

### apps/web/src/app/page.tsx

```tsx
"use client";

import { useState } from "react";
import { useCampaignWs } from "../lib/useCampaignWs";

export default function Page() {
  const [text, setText] = useState("");

  // Point to realtime service (dev)
  const { state, sendAction } = useCampaignWs({
    baseUrl: "http://localhost:8082",
    token: "dev-token",
    campaignId: "00000000-0000-0000-0000-000000000001", // use a real UUID you create
  });

  return (
    <div
      style={{ maxWidth: 900, margin: "20px auto", fontFamily: "system-ui" }}
    >
      <h2>RPG AI (v1) Realtime Test</h2>

      <div
        style={{
          padding: 12,
          border: "1px solid #ddd",
          borderRadius: 8,
          marginBottom: 12,
        }}
      >
        <div>
          <b>Connected:</b> {String(state.connected)}
        </div>
        <div>
          <b>Last seq:</b> {state.lastSeq}
        </div>
        {state.pendingGap && (
          <div style={{ color: "crimson" }}>
            Gap detected: expected {state.pendingGap.expected} got{" "}
            {state.pendingGap.got}
          </div>
        )}
        {state.errors.length > 0 && (
          <div style={{ color: "crimson" }}>
            {state.errors.map((e, i) => (
              <div key={i}>{e}</div>
            ))}
          </div>
        )}
      </div>

      <div
        style={{
          padding: 12,
          border: "1px solid #ddd",
          borderRadius: 8,
          height: 420,
          overflow: "auto",
        }}
      >
        {state.feed.map((item) => (
          <div key={item.seq} style={{ marginBottom: 10 }}>
            <div style={{ fontSize: 12, opacity: 0.7 }}>
              #{item.seq} • {item.kind.toUpperCase()}
            </div>
            <div style={{ whiteSpace: "pre-wrap" }}>{item.text}</div>
            {item.kind === "dm" && item.meta?.options?.length ? (
              <div
                style={{
                  marginTop: 6,
                  display: "flex",
                  gap: 8,
                  flexWrap: "wrap",
                }}
              >
                {item.meta.options.map((opt: string, idx: number) => (
                  <button
                    key={idx}
                    onClick={() => sendAction(opt)}
                    style={{
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid #ccc",
                    }}
                  >
                    {opt}
                  </button>
                ))}
              </div>
            ) : null}
          </div>
        ))}
      </div>

      <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
        <input
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Type an action..."
          style={{
            flex: 1,
            padding: 10,
            borderRadius: 8,
            border: "1px solid #ccc",
          }}
        />
        <button
          onClick={() => {
            if (!text.trim()) return;
            sendAction(text.trim());
            setText("");
          }}
          style={{
            padding: "10px 14px",
            borderRadius: 8,
            border: "1px solid #ccc",
          }}
        >
          Send
        </button>
      </div>
    </div>
  );
}
```

---

## 8) Quick "how to run" checklist

1. **Start DB + Redis**

   ```bash
   docker compose -f infra/docker/docker-compose.yml up -d
   ```

2. **Run migrations (psql)**

   ```bash
   psql "postgres://rpgai:rpgai@localhost:5432/rpgai" -f packages/db/sql/001_core.sql
   ```

3. **Insert a dummy campaign snapshot row** (use same UUID as UI)

   ```sql
   insert into game_snapshot (campaign_id, last_seq, state)
   values ('00000000-0000-0000-0000-000000000001', 0, '{"edition":"5e","mode":"free","scene":{"title":"Start","short_summary":"Begin.","present_npcs":[],"present_characters":[]},"rules_flags":{"strict":true}}')
   on conflict (campaign_id) do nothing;
   ```

4. **Start realtime**

   ```bash
   cd apps/realtime
   pnpm i
   pnpm dev
   ```

5. **Start web**
   ```bash
   cd apps/web
   pnpm i
   pnpm dev
   ```

Open the web app, type actions — you'll see `player_action` and a stub `dm_narration` come back.

Your realtime server already has the right shape. Next step is replacing the "DM stub" with a call to llm-orchestrator, then adding:

- roll_requested / roll_result (server-generated)
- state*patch*\* (validated)
- RAG search + prompt injection
